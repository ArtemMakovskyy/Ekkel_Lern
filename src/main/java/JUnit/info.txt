https://www.jetbrains.com/help/idea/create-tests.html#naming-pattern-for-tests
https://www.360logica.com/blog/how-to-use-junit-library-in-java-project/

========================================
https://coderlessons.com/tutorials/java-tekhnologii/vyuchit-junit/junit-kratkoe-rukovodstvo

JUnit — Краткое руководство
Март 16, 2019
JUnit — Обзор
Тестирование — это процесс проверки функциональности приложения на предмет его соответствия требованиям. Модульное тестирование входит в картину на уровне разработчиков; это тестирование отдельного объекта (класса или метода). Модульное тестирование играет решающую роль в оказании помощи софтверной компании в предоставлении качественных продуктов своим клиентам.

Модульное тестирование может быть выполнено двумя способами — вручную и автоматически.

Ручное тестирование	Автоматизированное тестирование
Выполнение тестовых случаев вручную без какой-либо поддержки инструмента называется ручным тестированием.	Получение поддержки инструмента и выполнение тестовых случаев с использованием инструмента автоматизации называется автоматизацией тестирования.
Отнимает много времени и утомительно — так как тесты выполняются человеческими ресурсами, это очень медленно и утомительно.	Быстро — автоматизация запускает тестовые случаи значительно быстрее, чем человеческие ресурсы.
Огромные инвестиции в человеческие ресурсы — поскольку тестовые примеры должны выполняться вручную, для ручного тестирования требуется больше тестировщиков.	Меньше инвестиций в человеческие ресурсы. Тестовые случаи выполняются с использованием средств автоматизации, поэтому для тестирования автоматизации требуется меньше тестеров.
Менее надежный — ручное тестирование менее надежно, так как оно должно учитывать человеческие ошибки.	Надежнее — автоматические тесты точны и надежны.
Непрограммируемый — не может быть никакого программирования для написания сложных тестов для извлечения скрытой информации.	Программируемый — тестировщики могут программировать сложные тесты, чтобы выявлять скрытую информацию.
Что такое Юнит?
JUnit — это инфраструктура модульного тестирования для языка программирования Java. Он играет решающую роль при разработке на основе тестов и представляет собой семейство платформ модульного тестирования, известных под общим названием xUnit.

JUnit продвигает идею «сначала тестирование, а затем кодирование», которая делает упор на настройке тестовых данных для фрагмента кода, который можно сначала протестировать, а затем реализовать. Этот подход похож на «немного протестировать, немного кодировать, немного протестировать, немного кодировать». Это увеличивает производительность программиста и стабильность программного кода, что, в свою очередь, снижает нагрузку на программиста и время, затрачиваемое на отладку.

Особенности JUnit
JUnit — это платформа с открытым исходным кодом, которая используется для написания и запуска тестов.

Предоставляет аннотации для определения методов испытаний.

Предоставляет утверждения для тестирования ожидаемых результатов.

Предоставляет тестовые бегуны для запуска тестов.

Тесты JUnit позволяют писать коды быстрее, что повышает качество.

Юнит элегантно прост. Это менее сложный и занимает меньше времени.

Тесты JUnit можно запускать автоматически, они проверяют свои результаты и предоставляют немедленную обратную связь. Нет необходимости вручную прочесывать отчет с результатами теста.

Тесты JUnit могут быть организованы в наборы тестов, содержащие тестовые наборы и даже другие наборы тестов.

JUnit отображает ход выполнения теста на зеленой полосе, если тест проходит гладко, и становится красным при сбое теста.

JUnit — это платформа с открытым исходным кодом, которая используется для написания и запуска тестов.

Предоставляет аннотации для определения методов испытаний.

Предоставляет утверждения для тестирования ожидаемых результатов.

Предоставляет тестовые бегуны для запуска тестов.

Тесты JUnit позволяют писать коды быстрее, что повышает качество.

Юнит элегантно прост. Это менее сложный и занимает меньше времени.

Тесты JUnit можно запускать автоматически, они проверяют свои результаты и предоставляют немедленную обратную связь. Нет необходимости вручную прочесывать отчет с результатами теста.

Тесты JUnit могут быть организованы в наборы тестов, содержащие тестовые наборы и даже другие наборы тестов.

JUnit отображает ход выполнения теста на зеленой полосе, если тест проходит гладко, и становится красным при сбое теста.

Что такое модульный тест?
Модульный тестовый пример — это часть кода, которая гарантирует, что другая часть кода (метода) работает так, как ожидается. Для быстрого достижения желаемых результатов требуется тестовая структура. JUnit — это идеальный фреймворк модульного тестирования для языка программирования Java.

Формальный письменный пример модульного теста характеризуется известными входными данными и ожидаемым выходным сигналом, которые вырабатываются до выполнения теста. Известный вход должен проверять предварительное условие, а ожидаемый результат должен проверять постусловие.

Для каждого требования должно быть не менее двух тестовых случаев — один положительный и один отрицательный. Если у требования есть под-требования, у каждого под-требования должно быть по крайней мере два контрольных примера как положительный и отрицательный.

JUnit — настройка среды
Настройка локальной среды
JUnit — это фреймворк для Java, поэтому самое первое требование — установить JDK на вашем компьютере.

Системные требования
JDK	1,5 или выше.
объем памяти	Нет минимальных требований.
Дисковое пространство	Нет минимальных требований.
Операционная система	Нет минимальных требований.
Шаг 1: Проверьте установку Java на вашем компьютере
Прежде всего, откройте консоль и выполните команду Java в зависимости от операционной системы, с которой вы работаете.

Операционные системы	задача	команда
Windows	Открытая командная консоль	c: \> Java-версия
Linux	Открытый командный терминал	$ java-версия
макинтош	Открытый терминал	машина: ~ Джозеф $ Java-версия
Давайте проверим вывод для всех операционных систем —

Операционные системы	Выход
Windows
Java-версия «1.8.0_101»

Java (TM) SE Runtime Environment (сборка 1.8.0_101)

Linux
Java-версия «1.8.0_101»

Java (TM) SE Runtime Environment (сборка 1.8.0_101)

макинтош
Java-версия «1.8.0_101»

Java (TM) SE Runtime Environment (сборка 1.8.0_101)

Java-версия «1.8.0_101»

Java (TM) SE Runtime Environment (сборка 1.8.0_101)

Java-версия «1.8.0_101»

Java (TM) SE Runtime Environment (сборка 1.8.0_101)

Java-версия «1.8.0_101»

Java (TM) SE Runtime Environment (сборка 1.8.0_101)

Если у вас не установлена ​​Java в вашей системе, загрузите Java Software Development Kit (SDK) по следующей ссылке https://www.oracle.com . Мы принимаем Java 1.8.0_101 в качестве установленной версии для этого урока.

Шаг 2: Установите среду JAVA
Установите переменную среды JAVA_HOME, чтобы она указывала на местоположение базовой директории, где установлена ​​Java на вашем компьютере. Например.

Операционные системы	Выход
Windows	Установите переменную среды JAVA_HOME в C: \ Program Files \ Java \ jdk1.8.0_101
Linux	экспорт JAVA_HOME = / usr / local / java-current
макинтош	export JAVA_HOME = / Библиотека / Java / Главная
Добавьте местоположение компилятора Java в системный путь.

Операционные системы	Выход
Windows	Добавьте строку C: \ Program Files \ Java \ jdk1.8.0_101 \ bin в конце системной переменной Path .
Linux	экспорт PATH = $ PATH: $ JAVA_HOME / bin /
макинтош	не требуется
Проверьте установку Java с помощью команды java -version, как описано выше.

Шаг 3: Скачать архив JUnit
Загрузите последнюю версию JAR-файла JUnit с http://www.junit.org . На момент написания этого руководства мы загрузили файл Junit-4.12.jar и скопировали его в папку C: \> JUnit.

Операционные системы	Название архива
Windows	junit4.12.jar
Linux	junit4.12.jar
макинтош	junit4.12.jar
Шаг 4: Установите среду JUnit
Установите переменную среды JUNIT_HOME, чтобы она указывала на местоположение базовой директории, где на вашем компьютере хранится JUNIT jar. Предположим, что мы сохранили файл junit4.12.jar в папке JUNIT.

Sr.No	ОС и описание
1
Windows

Установите переменную окружения JUNIT_HOME в C: \ JUNIT

2
Linux

экспорт JUNIT_HOME = / usr / local / JUNIT

3
макинтош

экспорт JUNIT_HOME = / Библиотека / JUNIT

Windows

Установите переменную окружения JUNIT_HOME в C: \ JUNIT

Linux

экспорт JUNIT_HOME = / usr / local / JUNIT

макинтош



экспорт JUNIT_HOME = / Библиотека / JUNIT

Шаг 5: Установите переменную CLASSPATH
Установите переменную среды CLASSPATH, чтобы она указывала на расположение JAR JAR.

Sr.No	ОС и описание
1
Windows

Задайте для переменной среды CLASSPATH значение% CLASSPATH%;% JUNIT_HOME% \ junit4.12.jar;.;

2
Linux

export CLASSPATH = $ CLASSPATH: $ JUNIT_HOME / junit4.12.jar :.

3
макинтош

export CLASSPATH = $ CLASSPATH: $ JUNIT_HOME / junit4.12.jar :.

Windows

Задайте для переменной среды CLASSPATH значение% CLASSPATH%;% JUNIT_HOME% \ junit4.12.jar;.;

Linux

export CLASSPATH = $ CLASSPATH: $ JUNIT_HOME / junit4.12.jar :.

макинтош

export CLASSPATH = $ CLASSPATH: $ JUNIT_HOME / junit4.12.jar :.

Шаг 6: Проверка установки JUnit
Создайте файл класса Java с именем TestJunit в C: \> JUNIT_WORKSPACE

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class TestJunit {
   @Test

   public void testAdd() {
      String str = "Junit is working fine";
      assertEquals("Junit is working fine",str);
   }
}
Создайте файл класса Java с именем TestRunner в C: \> JUNIT_WORKSPACE для выполнения тестовых наборов .

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Шаг 7: Проверьте результат
Скомпилируйте классы, используя компилятор javac следующим образом:

C:\JUNIT_WORKSPACE>javac TestJunit.java TestRunner.java
Теперь запустите Test Runner, чтобы увидеть результат следующим образом:

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

true
JUnit — Тестовый фреймворк
JUnit — это среда регрессионного тестирования, используемая разработчиками для реализации модульного тестирования в Java, ускорения скорости программирования и повышения качества кода. JUnit Framework может быть легко интегрирован с одним из следующих:

Затмение
Муравей
специалист
Особенности JUnit Test Framework
Тестовый фреймворк JUnit предоставляет следующие важные функции —

арматура
Тестовые комплекты
Тест бегунов
JUnit классы
арматура
Fixtures — это фиксированное состояние набора объектов, используемых в качестве основы для выполнения тестов. Цель тестового устройства — обеспечить хорошо известную и фиксированную среду, в которой выполняются тесты, чтобы результаты можно было повторять. Включает в себя —

Метод setUp (), который запускается перед каждым вызовом теста.
Метод tearDown (), который запускается после каждого метода тестирования.
Давайте проверим один пример —

import junit.framework.*;

public class JavaTest extends TestCase {
   protected int value1, value2;

   // assigning the values
   protected void setUp(){
      value1 = 3;
      value2 = 3;
   }

   // test method to add two values
   public void testAdd(){
      double result = value1 + value2;
      assertTrue(result == 6);
   }
}
Test Suites
Набор тестов объединяет несколько примеров модульных тестов и запускает их вместе. В JUnit для запуска тестового набора используются аннотации @RunWith и @Suite. Ниже приведен пример, который использует тестовые классы TestJunit1 & TestJunit2.

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

//JUnit Suite Test
@RunWith(Suite.class)

@Suite.SuiteClasses({
   TestJunit1.class ,TestJunit2.class
})

public class JunitTestSuite {
}
import org.junit.Test;
import org.junit.Ignore;
import static org.junit.Assert.assertEquals;

public class TestJunit1 {

   String message = "Robert";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testPrintMessage() {
      System.out.println("Inside testPrintMessage()");
      assertEquals(message, messageUtil.printMessage());
   }
}
import org.junit.Test;
import org.junit.Ignore;
import static org.junit.Assert.assertEquals;

public class TestJunit2 {

   String message = "Robert";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testSalutationMessage() {
      System.out.println("Inside testSalutationMessage()");
      message = "Hi!" + "Robert";
      assertEquals(message,messageUtil.salutationMessage());
   }
}
Тест бегунов
Test Runner используется для выполнения тестовых случаев. Вот пример, который предполагает, что тестовый класс TestJunit уже существует.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
JUnit Классы
Классы JUnit являются важными классами, используемыми при написании и тестировании JUnits. Некоторые из важных классов —

Assert — Содержит набор методов assert.

TestCase — содержит тестовый набор, который определяет устройство для запуска нескольких тестов.

TestResult — содержит методы для сбора результатов выполнения контрольного примера.

Assert — Содержит набор методов assert.

TestCase — содержит тестовый набор, который определяет устройство для запуска нескольких тестов.

TestResult — содержит методы для сбора результатов выполнения контрольного примера.

JUnit — Основное использование
Давайте теперь представим базовый пример, демонстрирующий пошаговый процесс использования JUnit.

Создать класс
Создайте Java-класс для тестирования, скажем, MessageUtil.java в C: \> JUNIT_WORKSPACE

/*
* This class prints the given message on console.
*/

public class MessageUtil {

   private String message;

   //Constructor
   //@param message to be printed

   public MessageUtil(String message){
      this.message = message;
   }

   // prints the message
   public String printMessage(){
      System.out.println(message);
      return message;
   }
}
Создать тестовый класс
Создайте тестовый класс Java, скажем, TestJunit.java.
Добавьте тестовый метод testPrintMessage () в ваш тестовый класс.
Добавьте аннотацию @Test в метод testPrintMessage ().
Реализуйте условие теста и проверьте условие с помощью API assertEquals из JUnit.
Создайте имя файла класса java TestJunit.java в C: \> JUNIT_WORKSPACE .

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class TestJunit {

   String message = "Hello World";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testPrintMessage() {
      assertEquals(message,messageUtil.printMessage());
   }
}
Создать класс Runner Test
Создайте Java-класс TestRunner.
Используйте метод runClasses класса JUnitCore JUnit для запуска тестового примера созданного выше тестового класса.
Получить результат тестов, запущенных в Result Object.
Получите ошибки, используя метод getFailures () объекта Result.
Получите успех, используя метод wasSuccessful () объекта Result.
Создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте классы MessageUtil, Test case и Test Runner, используя javac.

C:\JUNIT_WORKSPACE>javac MessageUtil.java TestJunit.java TestRunner.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

Hello World
true
Теперь обновите TestJunit в C: \> JUNIT_WORKSPACE, чтобы тест не прошел . Измените строку сообщения.

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class TestJunit {

   String message = "Hello World";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testPrintMessage() {
      message = "New Word";
      assertEquals(message,messageUtil.printMessage());
   }
}
Давайте оставим остальные классы как есть и попробуем запустить тот же Test Runner.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {

   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

Hello World
testPrintMessage(TestJunit): expected:<[New Wor]d> but was:<[Hello Worl]d>
false
JUnit — API
Самый важный пакет в JUnit — это junit.framework , который содержит все основные классы. Некоторые из важных классов следующие:

Sr.No.	Имя класса	функциональность
1	утверждать	Набор методов assert.
2	Прецедент	Тестовый пример определяет прибор для запуска нескольких тестов.
3	Результат испытаний	TestResult собирает результаты выполнения контрольного примера.
4	Тестирование	TestSuite — это набор тестов.
Assert Class
Ниже приводится объявление для класса org.junit.Assert —

public class Assert extends java.lang.Object
Этот класс предоставляет набор методов утверждения, полезных для написания тестов. Только ошибочные утверждения записываются. Вот некоторые из важных методов класса Assert:

Sr.No.	Методы и описание
1
void assertEquals (логическое ожидание, логическое фактическое)

Проверяет, что два примитива / объекта равны.

2
void assertFalse (логическое условие)

Проверяет, что условие ложно.

3
void assertNotNull (Объектный объект)

Проверяет, что объект не является нулевым.

4
void assertNull (Объектный объект)

Проверяет, что объект является нулевым.

5
void assertTrue (логическое условие)

Проверяет, что условие верно.

6
void fail ()

Сбой теста без сообщения.

void assertEquals (логическое ожидание, логическое фактическое)

Проверяет, что два примитива / объекта равны.

void assertFalse (логическое условие)

Проверяет, что условие ложно.

void assertNotNull (Объектный объект)

Проверяет, что объект не является нулевым.

void assertNull (Объектный объект)

Проверяет, что объект является нулевым.

void assertTrue (логическое условие)

Проверяет, что условие верно.

void fail ()

Сбой теста без сообщения.

Давайте использовать некоторые из вышеупомянутых методов в примере. Создайте файл класса Java с именем TestJunit1.java в C: \> JUNIT_WORKSPACE .

import org.junit.Test;
import static org.junit.Assert.*;

public class TestJunit1 {
   @Test
   public void testAdd() {
      //test data
      int num = 5;
      String temp = null;
      String str = "Junit is working fine";

      //check for equality
      assertEquals("Junit is working fine", str);

      //check for false condition
      assertFalse(num > 6);

      //check for not null value
      assertNotNull(temp);
   }
}
Затем создайте файл класса java с именем TestRunner1.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner1 {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit1.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте тестовый набор и классы Runner, используя javac.

C:\JUNIT_WORKSPACE>javac TestJunit1.java TestRunner1.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner1
Проверьте вывод.

true
TestCase Class
Ниже приводится объявление для класса org.junit.TestCase —

public abstract class TestCase extends Assert implements Test
Тестовый пример определяет прибор для запуска нескольких тестов. Вот некоторые из важных методов класса TestCase :

Sr.No.	Методы и описание
1
int countTestCases ()

Подсчитывает количество тестов, выполненных при запуске (результат TestResult).

2
TestResult createResult ()

Создает объект TestResult по умолчанию.

3
Строка getName ()

Получает имя TestCase.

4
TestResult run ()

Удобный метод для запуска этого теста, собирающий результаты с помощью объекта TestResult по умолчанию.

5
void run (результат TestResult)

Запускает контрольный пример и собирает результаты в TestResult.

6
void setName (String name)

Устанавливает имя TestCase.

7
void setUp ()

Настраивает прибор, например, открывает сетевое соединение.

8
void tearDown ()

Срывает прибор, например, закрывает сетевое соединение.

9
Строка toString ()

Возвращает строковое представление контрольного примера.

int countTestCases ()

Подсчитывает количество тестов, выполненных при запуске (результат TestResult).

TestResult createResult ()

Создает объект TestResult по умолчанию.

Строка getName ()

Получает имя TestCase.

TestResult run ()

Удобный метод для запуска этого теста, собирающий результаты с помощью объекта TestResult по умолчанию.

void run (результат TestResult)

Запускает контрольный пример и собирает результаты в TestResult.

void setName (String name)

Устанавливает имя TestCase.

void setUp ()

Настраивает прибор, например, открывает сетевое соединение.

void tearDown ()

Срывает прибор, например, закрывает сетевое соединение.

Строка toString ()

Возвращает строковое представление контрольного примера.

Давайте использовать некоторые из вышеупомянутых методов в примере. Создайте файл класса Java с именем TestJunit2.java в C: \> JUNIT_WORKSPACE.

import junit.framework.TestCase;
import org.junit.Before;
import org.junit.Test;

public class TestJunit2 extends TestCase  {
   protected double fValue1;
   protected double fValue2;

   @Before
   public void setUp() {
      fValue1 = 2.0;
      fValue2 = 3.0;
   }

   @Test
   public void testAdd() {
      //count the number of test cases
      System.out.println("No of Test Case = "+ this.countTestCases());

      //test getName
      String name = this.getName();
      System.out.println("Test Case Name = "+ name);

      //test setName
      this.setName("testNewAdd");
      String newName = this.getName();
      System.out.println("Updated Test Case Name = "+ newName);
   }

   //tearDown used to close the connection or clean up activities
   public void tearDown(  ) {
   }
}
Затем создайте файл класса Java с именем TestRunner2.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner2 {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit2.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте тестовый набор и классы Runner, используя javac.

C:\JUNIT_WORKSPACE>javac TestJunit2.java TestRunner2.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner2
Проверьте вывод.

No of Test Case = 1
Test Case Name = testAdd
Updated Test Case Name = testNewAdd
true
TestResult Class
Ниже приводится объявление для класса org.junit.TestResult.

public class TestResult extends Object
TestResult собирает результаты выполнения контрольного примера. Это экземпляр шаблона Collecting Parameter. Тестовая структура различает сбои и ошибки. Ожидается сбой и проверяется с помощью утверждений. Ошибки — это непредвиденные проблемы, такие как ArrayIndexOutOfBoundsException. Вот некоторые из важных методов класса TestResult :

Sr.No.	Методы и описание
1
void addError (Тестовый тест, Throwable t)

Добавляет ошибку в список ошибок.

2
void addFailure (Тестовый тест, AssertionFailedError t)

Добавляет ошибку в список ошибок.

3
void endTest (Тестовый тест)

Сообщает результат, что тест был завершен.

4
int errorCount ()

Получает количество обнаруженных ошибок.

5
Перечисление <TestFailure> ошибки ()

Возвращает перечисление для ошибок.

6
int failCount ()

Получает количество обнаруженных сбоев.

7
void run (тестовый тест)

Запускает TestCase.

8
int runCount ()

Получает количество выполненных тестов.

9
void startTest (Тестовый тест)

Сообщает результат, что тест будет запущен.

10
остановка ()

Отмечает, что тестовый прогон должен быть остановлен.

void addError (Тестовый тест, Throwable t)

Добавляет ошибку в список ошибок.

void addFailure (Тестовый тест, AssertionFailedError t)

Добавляет ошибку в список ошибок.

void endTest (Тестовый тест)

 | Программирование
Data Scientist: машинное обучение
95 040 ₽
3 960 ₽/мес.
Подробнее
Data Scientist: машинное обучение
Сообщает результат, что тест был завершен.

int errorCount ()

Получает количество обнаруженных ошибок.

Перечисление <TestFailure> ошибки ()

Возвращает перечисление для ошибок.

int failCount ()

Получает количество обнаруженных сбоев.

void run (тестовый тест)

Запускает TestCase.

int runCount ()

Получает количество выполненных тестов.

void startTest (Тестовый тест)

Сообщает результат, что тест будет запущен.

остановка ()

Отмечает, что тестовый прогон должен быть остановлен.

Создайте файл класса Java с именем TestJunit3.java в C: \> JUNIT_WORKSPACE.

import org.junit.Test;
import junit.framework.AssertionFailedError;
import junit.framework.TestResult;

public class TestJunit3 extends TestResult {
   // add the error
   public synchronized void addError(Test test, Throwable t) {
      super.addError((junit.framework.Test) test, t);
   }

   // add the failure
   public synchronized void addFailure(Test test, AssertionFailedError t) {
      super.addFailure((junit.framework.Test) test, t);
   }

   @Test
   public void testAdd() {
      // add any test
   }

   // Marks that the test run should stop.
   public synchronized void stop() {
      //stop the test here
   }
}
Затем создайте файл класса Java с именем TestRunner3.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner3 {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit3.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте тестовый набор и классы Runner, используя javac.

C:\JUNIT_WORKSPACE>javac TestJunit3.java TestRunner3.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner3
Проверьте вывод.

true
TestSuite Class
Ниже приводится объявление для класса org.junit.TestSuite :

public class TestSuite extends Object implements Test
TestSuite — это совокупность тестов. Он запускает коллекцию тестовых случаев. Вот некоторые из важных методов класса TestSuite :

Sr.No.	Методы и описание
1
void addTest (Тестовый тест)

Добавляет тест в комплект.

2
void addTestSuite (Class <? extends TestCase> testClass)

Добавляет тесты из данного класса в комплект.

3
int countTestCases ()

Подсчитывает количество тестов, которые будут выполнены этим тестом.

4
Строка getName ()

Возвращает название сюиты.

5
void run (результат TestResult)

Запускает тесты и собирает их результаты в TestResult.

6
void setName (String name)

Устанавливает название сюиты.

7
Test testAt (int index)

Возвращает тест по заданному индексу.

8
int testCount ()

Возвращает количество тестов в этом наборе.

9
статическое тестовое предупреждение (строковое сообщение)

Возвращает тест, который не пройден, и регистрирует предупреждающее сообщение.

void addTest (Тестовый тест)

Добавляет тест в комплект.

void addTestSuite (Class <? extends TestCase> testClass)

Добавляет тесты из данного класса в комплект.

int countTestCases ()

Подсчитывает количество тестов, которые будут выполнены этим тестом.

Строка getName ()

Возвращает название сюиты.

void run (результат TestResult)

Запускает тесты и собирает их результаты в TestResult.

void setName (String name)

Устанавливает название сюиты.

Test testAt (int index)

Возвращает тест по заданному индексу.

int testCount ()

Возвращает количество тестов в этом наборе.

статическое тестовое предупреждение (строковое сообщение)

Возвращает тест, который не пройден, и регистрирует предупреждающее сообщение.

Создайте файл класса Java с именем JunitTestSuite.java в C: \> JUNIT_WORKSPACE, чтобы создать набор тестов.

import junit.framework.*;

public class JunitTestSuite {
   public static void main(String[] a) {
      // add the test's in the suite
      TestSuite suite = new TestSuite(TestJunit1.class, TestJunit2.class, TestJunit3.class );
      TestResult result = new TestResult();
      suite.run(result);
      System.out.println("Number of test cases = " + result.runCount());
   }
}
Скомпилируйте классы Test Suite, используя javac.

C:\JUNIT_WORKSPACE>javac JunitTestSuite.java
Теперь запустите Test Suite.

C:\JUNIT_WORKSPACE>java JunitTestSuite
Проверьте вывод.

No of Test Case = 1
Test Case Name = testAdd
Updated Test Case Name = testNewAdd
Number of test cases = 3
JUnit — Написание теста
Здесь мы увидим один полный пример тестирования JUnit с использованием класса POJO, класса бизнес-логики и класса тестирования, который будет запускаться исполнителем теста.

Создайте EmployeeDetails.java в C: \> JUNIT_WORKSPACE, который является классом POJO.

public class EmployeeDetails {

   private String name;
   private double monthlySalary;
   private int age;

   /**
   * @return the name
   */

   public String getName() {
      return name;
   }

   /**
   * @param name the name to set
   */

   public void setName(String name) {
      this.name = name;
   }

   /**
   * @return the monthlySalary
   */

   public double getMonthlySalary() {
      return monthlySalary;
   }

   /**
   * @param monthlySalary the monthlySalary to set
   */

   public void setMonthlySalary(double monthlySalary) {
      this.monthlySalary = monthlySalary;
   }

   /**
   * @return the age
   */
   public int getAge() {
      return age;
   }

   /**
   * @param age the age to set
   */
   public void setAge(int age) {
      this.age = age;
   }
}
Класс EmployeeDetails используется для —

получить / установить значение имени сотрудника.
получить / установить значение месячной зарплаты сотрудника.
получить / установить значение возраста работника.
Создайте файл с именем EmpBusinessLogic.java в C: \> JUNIT_WORKSPACE, который содержит бизнес-логику.

public class EmpBusinessLogic {
   // Calculate the yearly salary of employee
   public double calculateYearlySalary(EmployeeDetails employeeDetails) {
      double yearlySalary = 0;
      yearlySalary = employeeDetails.getMonthlySalary() * 12;
      return yearlySalary;
   }

   // Calculate the appraisal amount of employee
   public double calculateAppraisal(EmployeeDetails employeeDetails) {
      double appraisal = 0;

      if(employeeDetails.getMonthlySalary() < 10000){
         appraisal = 500;
      }else{
         appraisal = 1000;
      }

      return appraisal;
   }
}
Класс EmpBusinessLogic используется для расчета —

годовая зарплата работника.
сумма оценки работника.
Создайте файл с именем TestEmployeeDetails.java в C: \> JUNIT_WORKSPACE, который содержит тестовые наборы для тестирования.

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class TestEmployeeDetails {
   EmpBusinessLogic empBusinessLogic = new EmpBusinessLogic();
   EmployeeDetails employee = new EmployeeDetails();

   //test to check appraisal
   @Test
   public void testCalculateAppriasal() {
      employee.setName("Rajeev");
      employee.setAge(25);
      employee.setMonthlySalary(8000);

      double appraisal = empBusinessLogic.calculateAppraisal(employee);
      assertEquals(500, appraisal, 0.0);
   }

   // test to check yearly salary
   @Test
   public void testCalculateYearlySalary() {
      employee.setName("Rajeev");
      employee.setAge(25);
      employee.setMonthlySalary(8000);

      double salary = empBusinessLogic.calculateYearlySalary(employee);
      assertEquals(96000, salary, 0.0);
   }
}
Класс TestEmployeeDetails используется для тестирования методов класса EmpBusinessLogic . Это

проверяет годовую заработную плату работника.
проверяет сумму оценки работника.
Затем создайте Java-класс с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestEmployeeDetails.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте тестовый набор и классы Runner, используя javac.

C:\JUNIT_WORKSPACE>javac EmployeeDetails.java
EmpBusinessLogic.java TestEmployeeDetails.java TestRunner.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

true
JUnit — Использование утверждения
Утверждение
Все утверждения находятся в классе Assert.

public class Assert extends java.lang.Object
Этот класс предоставляет набор методов утверждения, полезных для написания тестов. Только ошибочные утверждения записываются. Вот некоторые из важных методов класса Assert:

Sr.No.	Методы и описание
1
void assertEquals (логическое ожидание, логическое фактическое)

Проверяет, что два примитива / объекта равны.

2
void assertTrue (логическое условие)

Проверяет, что условие верно.

3
void assertFalse (логическое условие)

Проверяет, что условие ложно.

4
void assertNotNull (Объектный объект)

Проверяет, что объект не является нулевым.

5
void assertNull (Объектный объект)

Проверяет, что объект является нулевым.

6
void assertSame (object1, object2)

Метод assertSame () проверяет, указывают ли две ссылки на один и тот же объект.

7
void assertNotSame (object1, object2)

Метод assertNotSame () проверяет, не ссылаются ли две ссылки на один и тот же объект.

8
void assertArrayEquals (pectedArray, resultArray);

Метод assertArrayEquals () проверит, равны ли два массива друг другу.

void assertEquals (логическое ожидание, логическое фактическое)

Проверяет, что два примитива / объекта равны.

void assertTrue (логическое условие)

Проверяет, что условие верно.

void assertFalse (логическое условие)

Проверяет, что условие ложно.

void assertNotNull (Объектный объект)

Проверяет, что объект не является нулевым.

void assertNull (Объектный объект)

Проверяет, что объект является нулевым.

void assertSame (object1, object2)

Метод assertSame () проверяет, указывают ли две ссылки на один и тот же объект.

void assertNotSame (object1, object2)

Метод assertNotSame () проверяет, не ссылаются ли две ссылки на один и тот же объект.

void assertArrayEquals (pectedArray, resultArray);

Метод assertArrayEquals () проверит, равны ли два массива друг другу.

Давайте использовать некоторые из вышеупомянутых методов в примере. Создайте файл класса Java с именем TestAssertions.java в C: \> JUNIT_WORKSPACE.

import org.junit.Test;
import static org.junit.Assert.*;

public class TestAssertions {

   @Test
   public void testAssertions() {
      //test data
      String str1 = new String ("abc");
      String str2 = new String ("abc");
      String str3 = null;
      String str4 = "abc";
      String str5 = "abc";

      int val1 = 5;
      int val2 = 6;

      String[] expectedArray = {"one", "two", "three"};
      String[] resultArray =  {"one", "two", "three"};

      //Check that two objects are equal
      assertEquals(str1, str2);

      //Check that a condition is true
      assertTrue (val1 < val2);

      //Check that a condition is false
      assertFalse(val1 > val2);

      //Check that an object isn't null
      assertNotNull(str1);

      //Check that an object is null
      assertNull(str3);

      //Check if two object references point to the same object
      assertSame(str4,str5);

      //Check if two object references not point to the same object
      assertNotSame(str1,str3);

      //Check whether two arrays are equal to each other.
      assertArrayEquals(expectedArray, resultArray);
   }
}
Затем создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner2 {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestAssertions.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте классы Test case и Test Runner, используя javac.

C:\JUNIT_WORKSPACE>javac TestAssertions.java TestRunner.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

true
аннотирование
Аннотации похожи на метатеги, которые вы можете добавить в свой код и применять их к методам или в классе. Эти аннотации в JUnit предоставляют следующую информацию о методах тестирования —

какие методы будут выполняться до и после методов тестирования.
какие методы выполняются до и после всех методов, и.
какие методы или классы будут игнорироваться во время выполнения.
В следующей таблице приведен список аннотаций и их значения в JUnit —

Sr.No.	Аннотация и описание
1
@Тестовое задание

Аннотация Test сообщает JUnit, что открытый метод void, к которому он присоединен, может быть запущен как тестовый пример.

2
@До

Несколько тестов нуждаются в похожих объектах, созданных до их запуска. Аннотирование открытого метода void с помощью @Before приводит к тому, что этот метод запускается перед каждым методом Test.

3
@После

Если вы выделяете внешние ресурсы в методе «До», вам необходимо освободить их после выполнения теста. Аннотирование открытого метода void с помощью @After приводит к тому, что этот метод запускается после метода Test.

4
@BeforeClass

Аннотирование открытого статического метода void с помощью @BeforeClass заставляет его запускаться один раз перед любым из тестовых методов в классе.

5
@После школы

Это выполнит метод после завершения всех тестов. Это может быть использовано для выполнения действий по очистке.

6
@Ignore

Аннотация Ignore используется для игнорирования теста, и этот тест не будет выполнен.

@Тестовое задание

Аннотация Test сообщает JUnit, что открытый метод void, к которому он присоединен, может быть запущен как тестовый пример.

@До

Несколько тестов нуждаются в похожих объектах, созданных до их запуска. Аннотирование открытого метода void с помощью @Before приводит к тому, что этот метод запускается перед каждым методом Test.

@После

Если вы выделяете внешние ресурсы в методе «До», вам необходимо освободить их после выполнения теста. Аннотирование открытого метода void с помощью @After приводит к тому, что этот метод запускается после метода Test.

@BeforeClass

Аннотирование открытого статического метода void с помощью @BeforeClass заставляет его запускаться один раз перед любым из тестовых методов в классе.

@После школы

Это выполнит метод после завершения всех тестов. Это может быть использовано для выполнения действий по очистке.

@Ignore

Аннотация Ignore используется для игнорирования теста, и этот тест не будет выполнен.

Создайте файл Java-класса с именем JunitAnnotation.java в C: \> JUNIT_WORKSPACE для проверки аннотации.

import org.junit.After;
import org.junit.AfterClass;

import org.junit.Before;
import org.junit.BeforeClass;

import org.junit.Ignore;
import org.junit.Test;

public class JunitAnnotation {

   //execute before class
   @BeforeClass
   public static void beforeClass() {
      System.out.println("in before class");
   }

   //execute after class
   @AfterClass
   public static void  afterClass() {
      System.out.println("in after class");
   }

   //execute before test
   @Before
   public void before() {
      System.out.println("in before");
   }

   //execute after test
   @After
   public void after() {
      System.out.println("in after");
   }

   //test case
   @Test
   public void test() {
      System.out.println("in test");
   }

   //test case ignore and will not execute
   @Ignore
   public void ignoreTest() {
      System.out.println("in ignore test");
   }
}
Затем создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения аннотаций.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(JunitAnnotation.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте классы Test case и Test Runner, используя javac.

C:\JUNIT_WORKSPACE>javac JunitAnnotation.java TestRunner.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

in before class
in before
in test
in after
in after class
true
JUnit — процедура исполнения
В этой главе описывается процедура выполнения методов в JUnit, которая определяет порядок вызываемых методов. Ниже обсуждается процедура выполнения методов API тестирования JUnit с примером.

Создайте файл Java-класса с именем ExecutionProcedureJunit.java в C: \> JUNIT_WORKSPACE для проверки аннотации.

import org.junit.After;
import org.junit.AfterClass;

import org.junit.Before;
import org.junit.BeforeClass;

import org.junit.Ignore;
import org.junit.Test;

public class ExecutionProcedureJunit {

   //execute only once, in the starting
   @BeforeClass
   public static void beforeClass() {
      System.out.println("in before class");
   }

   //execute only once, in the end
   @AfterClass
   public static void  afterClass() {
      System.out.println("in after class");
   }

   //execute for each test, before executing test
   @Before
   public void before() {
      System.out.println("in before");
   }

   //execute for each test, after executing test
   @After
   public void after() {
      System.out.println("in after");
   }

   //test case 1
   @Test
   public void testCase1() {
      System.out.println("in test case 1");
   }

   //test case 2
   @Test
   public void testCase2() {
      System.out.println("in test case 2");
   }
}
Затем создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения аннотаций.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(ExecutionProcedureJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте классы Test case и Test Runner, используя javac.

C:\JUNIT_WORKSPACE>javac ExecutionProcedureJunit.java TestRunner.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

in before class
in before
in test case 1
in after
in before
in test case 2
in after
in after class
Смотрите вышеприведенный вывод. Процедура выполнения выглядит следующим образом —

Прежде всего, метод beforeClass () выполняется только один раз.
Метод afterClass () выполняется только один раз.
Метод before () выполняется для каждого тестового примера, но перед его выполнением.
Метод after () выполняется для каждого тестового случая, но после выполнения тестового случая.
В промежутке между before () и after () выполняется каждый тест.
JUnit — Выполнение тестов
Тестовые случаи выполняются с использованием класса JUnitCore . JUnitCore — это фасад для запуска тестов. Он поддерживает запуск тестов JUnit 4, тестов JUnit 3.8.x и их смесей. Чтобы запустить тесты из командной строки, запустите java org.junit.runner.JUnitCore <TestClass>. Для однократных тестовых прогонов используйте статический метод runClasses (Class []).

Ниже приводится объявление для класса org.junit.runner.JUnitCore :

public class JUnitCore extends java.lang.Object
Здесь мы увидим, как выполнить тесты с помощью JUnitCore.

Создать класс
Создайте Java-класс для тестирования, скажем, MessageUtil.java , в C: \> JUNIT_WORKSPACE.

/*
* This class prints the given message on console.
*/

public class MessageUtil {

   private String message;

   //Constructor
   //@param message to be printed
   public MessageUtil(String message){
      this.message = message;
   }

   // prints the message
   public String printMessage(){
      System.out.println(message);
      return message;
   }

}
Создать тестовый класс
Создайте тестовый класс Java, скажем, TestJunit.java.

Добавьте тестовый метод testPrintMessage () в ваш тестовый класс.

Добавьте аннотацию @Test в метод testPrintMessage ().

Реализуйте условие теста и проверьте условие с помощью API assertEquals из JUnit.

Создайте тестовый класс Java, скажем, TestJunit.java.

Добавьте тестовый метод testPrintMessage () в ваш тестовый класс.

Добавьте аннотацию @Test в метод testPrintMessage ().

Реализуйте условие теста и проверьте условие с помощью API assertEquals из JUnit.

Создайте файл класса Java с именем TestJunit.java в C: \> JUNIT_WORKSPACE.

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class TestJunit {

   String message = "Hello World";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testPrintMessage() {
      assertEquals(message,messageUtil.printMessage());
   }
}
Создать класс Runner Test
Теперь создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE, чтобы выполнить тестовые сценарии. Он импортирует класс JUnitCore и использует метод runClasses (), который принимает имя тестового класса в качестве параметра.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте классы Test case и Test Runner, используя javac.

C:\JUNIT_WORKSPACE>javac MessageUtil.java TestJunit.java TestRunner.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

Hello World
true
JUnit — Suite Test
Набор тестов используется для объединения нескольких тестовых случаев и их запуска. В JUnit аннотации @RunWith и @Suite используются для запуска тестов комплекта. В этой главе приведен пример с двумя классами тестирования, TestJunit1 и TestJunit2 , которые работают вместе с помощью Test Suite.

Создать класс
Создайте Java-класс для тестирования, скажем, MessageUtil.java в C: \> JUNIT_WORKSPACE.

/*
* This class prints the given message on console.
*/

public class MessageUtil {

   private String message;

   //Constructor
   //@param message to be printed
   public MessageUtil(String message){
      this.message = message;
   }

   // prints the message
   public String printMessage(){
      System.out.println(message);
      return message;
   }

   // add "Hi!" to the message
   public String salutationMessage(){
      message = "Hi!" + message;
      System.out.println(message);
      return message;
   }
}
Создать классы теста
Создайте файл класса Java с именем TestJunit1.java в C: \> JUNIT_WORKSPACE.

import org.junit.Test;
import org.junit.Ignore;
import static org.junit.Assert.assertEquals;

public class TestJunit1 {

   String message = "Robert";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testPrintMessage() {
      System.out.println("Inside testPrintMessage()");
      assertEquals(message, messageUtil.printMessage());
   }
}
Создайте файл класса Java с именем TestJunit2.java в C: \> JUNIT_WORKSPACE.

import org.junit.Test;
import org.junit.Ignore;
import static org.junit.Assert.assertEquals;

public class TestJunit2 {

   String message = "Robert";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testSalutationMessage() {
      System.out.println("Inside testSalutationMessage()");
      message = "Hi!" + "Robert";
      assertEquals(message,messageUtil.salutationMessage());
   }
}
Создать класс Test Suite
Создайте класс Java.
Прикрепите @RunWith (Suite.class) Аннотация с классом.
Добавьте ссылку на тестовые классы JUnit, используя аннотацию @ Suite.SuiteClasses.
Создайте файл класса Java с именем TestSuite.java в C: \> JUNIT_WORKSPACE, чтобы выполнить тестовые сценарии.

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)

@Suite.SuiteClasses({
   TestJunit1.class,
   TestJunit2.class
})

public class JunitTestSuite {
}
Создать класс Runner Test
Создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(JunitTestSuite.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте все классы java, используя javac.

C:\JUNIT_WORKSPACE>javac MessageUtil.java TestJunit1.java
TestJunit2.java JunitTestSuite.java TestRunner.java
Теперь запустите Test Runner, который запустит тестовый набор, определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

Inside testPrintMessage()
Robert
Inside testSalutationMessage()
Hi Robert
true
JUnit — Игнорировать тест
Иногда бывает так, что наш код не полностью готов во время выполнения тестового примера. В результате контрольный пример не пройден. Аннотация @Ignore помогает в этом сценарии.

Тестовый метод, помеченный @Ignore, не будет выполнен.

Если тестовый класс помечен @Ignore, то ни один из его тестовых методов не будет выполнен.

Тестовый метод, помеченный @Ignore, не будет выполнен.

Если тестовый класс помечен @Ignore, то ни один из его тестовых методов не будет выполнен.

Теперь давайте посмотрим @Ignore в действии.

Создать класс
Создайте Java-класс для тестирования, скажем, MessageUtil.java в C: \> JUNIT_WORKSPACE.

/*
* This class prints the given message on console.
*/

public class MessageUtil {

   private String message;

   //Constructor
   //@param message to be printed
   public MessageUtil(String message){
      this.message = message;
   }

   // prints the message
   public String printMessage(){
      System.out.println(message);
      return message;
   }

   // add "Hi!" to the message
   public String salutationMessage(){
      message = "Hi!" + message;
      System.out.println(message);
      return message;
   }

}
Создать тестовый класс
Создайте тестовый класс Java, скажем, TestJunit.java.

Добавьте тестовый метод testPrintMessage () или testSalutationMessage () в ваш тестовый класс.

Добавьте аннотацию @Ignore в метод testPrintMessage ().

Создайте тестовый класс Java, скажем, TestJunit.java.

Добавьте тестовый метод testPrintMessage () или testSalutationMessage () в ваш тестовый класс.

Добавьте аннотацию @Ignore в метод testPrintMessage ().

Создайте файл класса Java с именем TestJunit.java в C: \ JUNIT_WORKSPACE.

import org.junit.Test;
import org.junit.Ignore;
import static org.junit.Assert.assertEquals;

public class TestJunit {

   String message = "Robert";
   MessageUtil messageUtil = new MessageUtil(message);

   @Ignore
   @Test
   public void testPrintMessage() {
      System.out.println("Inside testPrintMessage()");
      message = "Robert";
      assertEquals(message,messageUtil.printMessage());
   }

   @Test
   public void testSalutationMessage() {
      System.out.println("Inside testSalutationMessage()");
      message = "Hi!" + "Robert";
      assertEquals(message,messageUtil.salutationMessage());
   }

}
Создать класс Runner Test
Создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте классы MessageUtil, Test case и Test Runner, используя javac.

C:\JUNIT_WORKSPACE>javac MessageUtil.java TestJunit.java TestRunner.java
Теперь запустите Test Runner, который не будет запускать тестовый набор testPrintMessage (), определенный в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод. testPrintMessage () контрольный пример не проверен.

Inside testSalutationMessage()
Hi!Robert
true
Теперь обновите TestJunit в C: \> JUNIT_WORKSPACE, чтобы игнорировать все тестовые случаи. Добавьте @Ignore на уровне класса.

import org.junit.Test;
import org.junit.Ignore;
import static org.junit.Assert.assertEquals;

@Ignore
public class TestJunit {

   String message = "Robert";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testPrintMessage() {
      System.out.println("Inside testPrintMessage()");
      message = "Robert";
      assertEquals(message,messageUtil.printMessage());
   }

   @Test
   public void testSalutationMessage() {
      System.out.println("Inside testSalutationMessage()");
      message = "Hi!" + "Robert";
      assertEquals(message,messageUtil.salutationMessage());
   }

}
Скомпилируйте контрольный пример, используя javac.

C:\JUNIT_WORKSPACE>javac TestJunit.java
Оставьте тестового бегуна без изменений следующим образом:

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Теперь запустите Test Runner, который не будет запускать ни одного теста, определенного в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод. Ни один контрольный пример не проверен.

true
JUnit — Тест времени
JUnit предоставляет удобную опцию Timeout. Если тестовый случай занимает больше времени, чем указанное количество миллисекунд, JUnit автоматически помечает его как неудачный. Параметр timeout используется вместе с аннотацией @Test. Давайте посмотрим @Test (тайм-аут) в действии.

Создать класс
Создайте Java-класс для тестирования, скажем, MessageUtil.java в C: \> JUNIT_WORKSPACE.

Добавьте бесконечный цикл while внутри метода printMessage ().

/*
* This class prints the given message on console.
*/

public class MessageUtil {

   private String message;

   //Constructor
   //@param message to be printed
   public MessageUtil(String message){
      this.message = message;
   }

   // prints the message
   public void printMessage(){
      System.out.println(message);
      while(true);
   }

   // add "Hi!" to the message
   public String salutationMessage(){
      message = "Hi!" + message;
      System.out.println(message);
      return message;
   }
}
Создать тестовый класс
Создайте тестовый класс Java, скажем, TestJunit.java . Добавьте тайм-аут 1000 в testPrintMessage () контрольный пример.

Создайте файл класса Java с именем TestJunit.java в C: \> JUNIT_WORKSPACE.

import org.junit.Test;
import org.junit.Ignore;
import static org.junit.Assert.assertEquals;

public class TestJunit {

   String message = "Robert";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test(timeout = 1000)
   public void testPrintMessage() {
      System.out.println("Inside testPrintMessage()");
      messageUtil.printMessage();
   }

   @Test
   public void testSalutationMessage() {
      System.out.println("Inside testSalutationMessage()");
      message = "Hi!" + "Robert";
      assertEquals(message,messageUtil.salutationMessage());
   }
}
Создать класс Runner Test
Создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте классы MessageUtil, Test case и Test Runner, используя javac.

C:\JUNIT_WORKSPACE>javac MessageUtil.java TestJunit.java TestRunner.java
Теперь запустите Test Runner, который запустит тестовые наборы, определенные в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод. В тестовом примере testPrintMessage () будет указано, что модульное тестирование не выполнено.

Inside testPrintMessage()
Robert
Inside testSalutationMessage()
Hi!Robert
testPrintMessage(TestJunit): test timed out after 1000 milliseconds
false
JUnit — тест исключений
JUnit предоставляет возможность отслеживания обработки исключений в коде. Вы можете проверить, вызывает ли код желаемое исключение или нет. Ожидаемый параметр используется вместе с аннотацией @Test. Давайте посмотрим @Test (ожидается) в действии.

Создать класс
Создайте Java-класс для тестирования, скажем, MessageUtil.java в C: \> JUNIT_WORKSPACE.

Добавьте условие ошибки в метод printMessage ().

/*
* This class prints the given message on console.
*/

public class MessageUtil {

   private String message;

   //Constructor
   //@param message to be printed
   public MessageUtil(String message){
      this.message = message;
   }

   // prints the message
   public void printMessage(){
      System.out.println(message);
      int a = 0;
      int b = 1/a;
   }

   // add "Hi!" to the message
   public String salutationMessage(){
      message = "Hi!" + message;
      System.out.println(message);
      return message;
   }
}
Создать тестовый класс
Создайте тестовый класс Java с именем TestJunit.java . Добавьте ожидаемое исключение ArithmeticException в тестовый пример testPrintMessage ().

Создайте файл класса Java с именем TestJunit.java в C: \> JUNIT_WORKSPACE.

import org.junit.Test;
import org.junit.Ignore;
import static org.junit.Assert.assertEquals;

public class TestJunit {

   String message = "Robert";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test(expected = ArithmeticException.class)
   public void testPrintMessage() {
      System.out.println("Inside testPrintMessage()");
      messageUtil.printMessage();
   }

   @Test
   public void testSalutationMessage() {
      System.out.println("Inside testSalutationMessage()");
      message = "Hi!" + "Robert";
      assertEquals(message,messageUtil.salutationMessage());
   }
}
Создать класс Runner Test
Создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(TestJunit.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте классы MessageUtil, Test case и Test Runner, используя javac.

C:\JUNIT_WORKSPACE>javac MessageUtil.java TestJunit.java TestRunner.java
Теперь запустите Test Runner, который запустит тестовые наборы, определенные в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод. testPrintMessage () контрольный пример будет пройден.

Inside testPrintMessage()
Robert
Inside testSalutationMessage()
Hi!Robert
true
JUnit — параметризованный тест
JUnit 4 представил новую функцию под названием параметризованные тесты . Параметризованные тесты позволяют разработчику запускать один и тот же тест снова и снова, используя разные значения. Для создания параметризованного теста необходимо выполнить пять шагов.

Аннотируйте тестовый класс с помощью @RunWith (Parameterized.class).

Создайте открытый статический метод с аннотацией @Parameters, который возвращает коллекцию объектов (как массив) в качестве набора тестовых данных.

Создайте открытый конструктор, который принимает то, что эквивалентно одной «строке» тестовых данных.

Создайте переменную экземпляра для каждого «столбца» тестовых данных.

Создайте свои тестовые наборы, используя переменные экземпляра в качестве источника тестовых данных.

Аннотируйте тестовый класс с помощью @RunWith (Parameterized.class).

Создайте открытый статический метод с аннотацией @Parameters, который возвращает коллекцию объектов (как массив) в качестве набора тестовых данных.

Создайте открытый конструктор, который принимает то, что эквивалентно одной «строке» тестовых данных.

Создайте переменную экземпляра для каждого «столбца» тестовых данных.

Создайте свои тестовые наборы, используя переменные экземпляра в качестве источника тестовых данных.

Тестовый случай будет вызываться один раз для каждой строки данных. Давайте посмотрим параметризованные тесты в действии.

Создать класс
Создайте класс Java для тестирования, скажем, PrimeNumberChecker.java в C: \> JUNIT_WORKSPACE.

public class PrimeNumberChecker {
   public Boolean validate(final Integer primeNumber) {
      for (int i = 2; i < (primeNumber / 2); i++) {
         if (primeNumber % i == 0) {
            return false;
         }
      }
      return true;
   }
}
Создать параметризованный класс теста
Создайте тестовый класс Java, скажем, PrimeNumberCheckerTest.java . Создайте файл Java-класса с именем PrimeNumberCheckerTest.java в C: \> JUNIT_WORKSPACE.

import java.util.Arrays;
import java.util.Collection;

import org.junit.Test;
import org.junit.Before;

import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;
import org.junit.runner.RunWith;
import static org.junit.Assert.assertEquals;

@RunWith(Parameterized.class)
public class PrimeNumberCheckerTest {
   private Integer inputNumber;
   private Boolean expectedResult;
   private PrimeNumberChecker primeNumberChecker;

   @Before
   public void initialize() {
      primeNumberChecker = new PrimeNumberChecker();
   }

   // Each parameter should be placed as an argument here
   // Every time runner triggers, it will pass the arguments
   // from parameters we defined in primeNumbers() method

   public PrimeNumberCheckerTest(Integer inputNumber, Boolean expectedResult) {
      this.inputNumber = inputNumber;
      this.expectedResult = expectedResult;
   }

   @Parameterized.Parameters
   public static Collection primeNumbers() {
      return Arrays.asList(new Object[][] {
         { 2, true },
         { 6, false },
         { 19, true },
         { 22, false },
         { 23, true }
      });
   }

   // This test will run 4 times since we have 5 parameters defined
   @Test
   public void testPrimeNumberChecker() {
      System.out.println("Parameterized Number is : " + inputNumber);
      assertEquals(expectedResult,
      primeNumberChecker.validate(inputNumber));
   }
}
Создать класс Runner Test
Создайте файл класса Java с именем TestRunner.java в C: \> JUNIT_WORKSPACE для выполнения тестовых примеров.

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

public class TestRunner {
   public static void main(String[] args) {
      Result result = JUnitCore.runClasses(PrimeNumberCheckerTest.class);

      for (Failure failure : result.getFailures()) {
         System.out.println(failure.toString());
      }

      System.out.println(result.wasSuccessful());
   }
}
Скомпилируйте классы PrimeNumberChecker, PrimeNumberCheckerTest и Test Runner, используя javac.

C:\JUNIT_WORKSPACE>javac PrimeNumberChecker.java PrimeNumberCheckerTest.java
TestRunner.java
Теперь запустите Test Runner, который запустит тестовые наборы, определенные в предоставленном классе Test Case.

C:\JUNIT_WORKSPACE>java TestRunner
Проверьте вывод.

Parameterized Number is : 2
Parameterized Number is : 6
Parameterized Number is : 19
Parameterized Number is : 22
Parameterized Number is : 23
true
JUnit — подключи с ANT
У нас будет пример, демонстрирующий, как запустить JUnit с помощью ANT. Следуйте инструкциям ниже.

Шаг 1: Загрузите Apache Ant
Загрузите Apache Ant в зависимости от операционной системы, над которой вы работаете.

Операционные системы	Название архива
Windows	apache-ant-1.8.4-bin.zip
Linux	апач-муравей-1.8.4-bin.tar.gz
макинтош	апач-муравей-1.8.4-bin.tar.gz
Шаг 2: Установите среду Ant
Установите переменную среды ANT_HOME, чтобы она указывала на местоположение базовой директории, где на вашем компьютере хранятся библиотеки ANT. Предположим, библиотеки Ant хранятся в папке apache-ant-1.8.4.

Sr.No.	ОС и описание
1
Windows

Установите переменную среды ANT_HOME в C: \ Program Files \ Apache Software Foundation \ apache-ant-1.8.4

2
Linux

export ANT_HOME = /usr/local/apache-ant-1.8.4

3
макинтош

export ANT_HOME = /Library/apache-ant-1.8.4

Windows

Установите переменную среды ANT_HOME в C: \ Program Files \ Apache Software Foundation \ apache-ant-1.8.4

Linux

export ANT_HOME = /usr/local/apache-ant-1.8.4

макинтош

export ANT_HOME = /Library/apache-ant-1.8.4

Добавьте расположение компилятора Ant в системный путь следующим образом:

Операционные системы	Выход
Windows	Добавьте строку % ANT_HOME \ bin в конце системной переменной Path .
Linux	экспорт PATH = $ PATH: $ ANT_HOME / bin /
макинтош	не требуется
Шаг 3: Скачать архив JUnit
Загрузите JUnit Archive, подходящий для вашей операционной системы.

Операционные системы	Название архива
Windows	junit4.10.jar
Linux	junit4.10.jar
макинтош	junit4.10.jar
Шаг 4: Создать структуру проекта
Создайте папку TestJunitWithAnt в C: \> JUNIT_WORKSPACE.

Создайте папку src в C: \> JUNIT_WORKSPACE> TestJunitWithAnt.

Создайте тест папки в C: \> JUNIT_WORKSPACE> TestJunitWithAnt.

Создайте папку lib в C: \> JUNIT_WORKSPACE> TestJunitWithAnt.

Создайте класс MessageUtil в C: \> JUNIT_WORKSPACE> TestJunitWithAnt> srcfolder.

Создайте папку TestJunitWithAnt в C: \> JUNIT_WORKSPACE.

Создайте папку src в C: \> JUNIT_WORKSPACE> TestJunitWithAnt.

Создайте тест папки в C: \> JUNIT_WORKSPACE> TestJunitWithAnt.

Создайте папку lib в C: \> JUNIT_WORKSPACE> TestJunitWithAnt.

Создайте класс MessageUtil в C: \> JUNIT_WORKSPACE> TestJunitWithAnt> srcfolder.

/*
* This class prints the given message on console.
*/

public class MessageUtil {

   private String message;

   //Constructor
   //@param message to be printed
   public MessageUtil(String message){
      this.message = message;
   }

   // prints the message
   public String printMessage(){
      System.out.println(message);
      return message;
   }

   // add "Hi!" to the message
   public String salutationMessage(){
      message = "Hi!" + message;
      System.out.println(message);
      return message;
   }
}
Создайте класс TestMessageUtil в папке C: \> JUNIT_WORKSPACE> TestJunitWithAnt> src.

import org.junit.Test;
import org.junit.Ignore;
import static org.junit.Assert.assertEquals;

public class TestMessageUtil {

   String message = "Robert";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testPrintMessage() {
      System.out.println("Inside testPrintMessage()");
      assertEquals(message,messageUtil.printMessage());
   }

   @Test
   public void testSalutationMessage() {
      System.out.println("Inside testSalutationMessage()");
      message = "Hi!" + "Robert";
      assertEquals(message,messageUtil.salutationMessage());
   }
}
Скопируйте junit-4.10.jar в папку C: \> JUNIT_WORKSPACE> TestJunitWithAnt> lib.

Создать ANT Build.xml
Мы будем использовать задачу <junit> в Ant для выполнения наших тестовых случаев JUnit.

<project name = "JunitTest" default = "test" basedir = ".">
   <property name = "testdir" location = "test" />
   <property name = "srcdir" location = "src" />
   <property name = "full-compile" value = "true" />

   <path id = "classpath.base"/>

   <path id = "classpath.test">
      <pathelement location = "lib/junit-4.10.jar" />
      <pathelement location = "${testdir}" />
      <pathelement location = "${srcdir}" />
      <path refid = "classpath.base" />
   </path>

   <target name = "clean" >
      <delete verbose = "${full-compile}">
         <fileset dir = "${testdir}" includes = "**/*.class" />
      </delete>
   </target>

   <target name = "compile" depends = "clean">
      <javac srcdir = "${srcdir}" destdir = "${testdir}"
         verbose = "${full-compile}">
         <classpath refid = "classpath.test"/>
      </javac>
   </target>

   <target name = "test" depends = "compile">
      <junit>
         <classpath refid = "classpath.test" />
         <formatter type = "brief" usefile = "false" />
         <test name = "TestMessageUtil" />
      </junit>
   </target>

</project>
Запустите следующую команду Ant.

C:\JUNIT_WORKSPACE\TestJunitWithAnt>ant
Проверьте вывод.

Buildfile: C:\JUNIT_WORKSPACE\TestJunitWithAnt\build.xml

clean:

compile:
   [javac] Compiling 2 source files to C:\JUNIT_WORKSPACE\TestJunitWithAnt\test
   [javac] [parsing started C:\JUNIT_WORKSPACE\TestJunitWithAnt\src\
      MessageUtil.java]
   [javac] [parsing completed 18ms]
   [javac] [parsing started C:\JUNIT_WORKSPACE\TestJunitWithAnt\src\
      TestMessageUtil.java]
   [javac] [parsing completed 2ms]
   [javac]
   [javac] [loading java\lang\Object.class(java\lang:Object.class)]
   [javac] [loading java\lang\String.class(java\lang:String.class)]
   [javac] [loading org\junit\Test.class(org\junit:Test.class)]
   [javac] [loading org\junit\Ignore.class(org\junit:Ignore.class)]
   [javac] [loading org\junit\Assert.class(org\junit:Assert.class)]
   [javac] [loading java\lang\annotation\Retention.class
      (java\lang\annotation:Retention.class)]
   [javac] [loading java\lang\annotation\RetentionPolicy.class
      (java\lang\annotation:RetentionPolicy.class)]
   [javac] [loading java\lang\annotation\Target.class
      (java\lang\annotation:Target.class)]
   [javac] [loading java\lang\annotation\ElementType.class
      (java\lang\annotation:ElementType.class)]
   [javac] [loading java\lang\annotation\Annotation.class
      (java\lang\annotation:Annotation.class)]
   [javac] [checking MessageUtil]
   [javac] [loading java\lang\System.class(java\lang:System.class)]
   [javac] [loading java\io\PrintStream.class(java\io:PrintStream.class)]
   [javac] [loading java\io\FilterOutputStream.class
      (java\io:FilterOutputStream.class)]
   [javac] [loading java\io\OutputStream.class(java\io:OutputStream.class)]
   [javac] [loading java\lang\StringBuilder.class
      (java\lang:StringBuilder.class)]
   [javac] [loading java\lang\AbstractStringBuilder.class
      (java\lang:AbstractStringBuilder.class)]
   [javac] [loading java\lang\CharSequence.class(java\lang:CharSequence.class)]
   [javac] [loading java\io\Serializable.class(java\io:Serializable.class)]
   [javac] [loading java\lang\Comparable.class(java\lang:Comparable.class)]
   [javac] [loading java\lang\StringBuffer.class(java\lang:StringBuffer.class)]
   [javac] [wrote C:\JUNIT_WORKSPACE\TestJunitWithAnt\test\MessageUtil.class]
   [javac] [checking TestMessageUtil]
   [javac] [wrote C:\JUNIT_WORKSPACE\TestJunitWithAnt\test\TestMessageUtil.class]
   [javac] [total 281ms]

test:
    [junit] Testsuite: TestMessageUtil
    [junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0.008 sec
    [junit]
    [junit] ------------- Standard Output ---------------
    [junit] Inside testPrintMessage()
    [junit] Robert
    [junit] Inside testSalutationMessage()
    [junit] Hi!Robert
    [junit] ------------- ---------------- ---------------

BUILD SUCCESSFUL
Total time: 0 seconds
JUnit — подключи с Eclipse
Чтобы настроить JUnit с помощью eclipse, выполните следующие действия.

Шаг 1: Загрузите JUnit Archive
Загрузите JUnit jar на основе операционной системы, установленной в вашей системе.

Операционные системы	Название архива
Windows	junit4.10.jar
Linux	junit4.10.jar
макинтош	junit4.10.jar
Предположим, вы скопировали указанный выше JAR-файл в папку C: \> JUnit.

Шаг 2: Установите среду Eclipse
Откройте eclipse → щелкните правой кнопкой мыши проект и выберите свойство> Build Path> Configure Build Path и добавьте junit-4.10.jar в библиотеки с помощью кнопки Add External Jar.

Добавьте junit-4.10.jar в библиотеки.
Мы предполагаем, что ваш Eclipse имеет встроенный плагин JUnit. Если он недоступен в каталоге C: \> eclipse \ plugins, вы можете скачать его из плагина JUnit . Разархивируйте загруженный zip-файл в папку плагинов Eclipse. Наконец перезапустите Eclipse.

Теперь ваш Eclipse готов к разработке тестовых случаев JUnit.

Шаг 3: Проверьте установку JUnit в Eclipse
Создайте проект TestJunit в Eclipse в любом месте. Затем создайте класс MessageUtil для тестирования в проекте.


/*
* This class prints the given message on console.
*/

public class MessageUtil {

   private String message;

   //Constructor
   //@param message to be printed
   public MessageUtil(String message){
      this.message = message;
   }

   // prints the message
   public String printMessage(){
      System.out.println(message);
      return message;
   }
}
Создайте тестовый класс TestJunit в проекте.


import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class TestJunit {

   String message = "Hello World";
   MessageUtil messageUtil = new MessageUtil(message);

   @Test
   public void testPrintMessage() {
      assertEquals(message,messageUtil.printMessage());
   }
}
Ниже должна быть структура проекта —

Структура проекта
Наконец, щелкните правой кнопкой мыши программу и запустите ее как JUnit, чтобы проверить вывод программы.

Run Junit
Проверьте результат.

Юнит результат успеха.
JUnit — Расширения
Ниже приведены расширения JUnit —

Кактус
JWebUnit
XMLUnit
MockObject
Кактус
Cactus — это простая тестовая среда для модульного тестирования Java-кода на стороне сервера (сервлеты, EJB, библиотеки тегов, фильтры). Цель Cactus — снизить стоимость написания тестов для серверного кода. Он использует JUnit и расширяет его. Cactus реализует стратегию в контейнере, которая выполняет тесты внутри контейнера.

Экосистема кактуса состоит из нескольких компонентов —

Cactus Framework — это сердце Кактуса. Это движок, который предоставляет API для написания тестов Cactus.

Интеграционные модули Cactus — это внешние интерфейсы и платформы, которые предоставляют простые способы использования Cactus Framework (скрипты Ant, плагин Eclipse и плагин Maven).

Cactus Framework — это сердце Кактуса. Это движок, который предоставляет API для написания тестов Cactus.

Интеграционные модули Cactus — это внешние интерфейсы и платформы, которые предоставляют простые способы использования Cactus Framework (скрипты Ant, плагин Eclipse и плагин Maven).

Следующий код демонстрирует, как можно использовать Cactus.

import org.apache.cactus.*;
import junit.framework.*;

public class TestSampleServlet extends ServletTestCase {
   @Test
   public void testServlet() {
      // Initialize class to test
      SampleServlet servlet = new SampleServlet();

      // Set a variable in session as the doSomething()
      // method that we are testing
      session.setAttribute("name", "value");

      // Call the method to test, passing an
      // HttpServletRequest object (for example)
      String result = servlet.doSomething(request);

      // Perform verification that test was successful
      assertEquals("something", result);
      assertEquals("otherValue", session.getAttribute("otherName"));
   }
}
JWebUnit
JWebUnit — это основанная на Java среда тестирования веб-приложений. Он объединяет существующие платформы тестирования, такие как HtmlUnit и Selenium, с унифицированным простым интерфейсом тестирования для проверки правильности ваших веб-приложений.

JWebUnit предоставляет высокоуровневый Java API для навигации по веб-приложению в сочетании с набором утверждений для проверки правильности приложения. Сюда входит навигация по ссылкам, ввод и отправка форм, проверка содержимого таблицы и другие типичные функции веб-приложений для бизнеса.

Простые методы навигации и готовые к использованию утверждения позволяют быстрее создавать тесты, чем при использовании только JUnit или HtmlUnit. И если вы хотите переключиться с HtmlUnit на другие плагины, такие как Selenium (скоро будет доступно), вам не нужно переписывать свои тесты.

Вот пример кода.

import junit.framework.TestCase;
import net.sourceforge.jwebunit.WebTester;

public class ExampleWebTestCase extends TestCase {
   private WebTester tester;

   public ExampleWebTestCase(String name) {
      super(name);
      tester = new WebTester();
   }

   //set base url
   public void setUp() throws Exception {
      getTestContext().setBaseUrl("http://myserver:8080/myapp");
   }

   // test base info
   @Test
   public void testInfoPage() {
      beginAt("/info.html");
   }
}
XMLUnit
XMLUnit предоставляет один класс расширения JUnit, XMLTestCase, и набор вспомогательных классов, которые позволяют делать утверждения относительно:

Различия между двумя частями XML (через классы Diff и DetailDiff).

Допустимость фрагмента XML (через класс Validator).

Результат преобразования фрагмента XML с использованием XSLT (через класс Transform).

Оценка выражения XPath на фрагменте XML (через классы, реализующие интерфейс XpathEngine).

Отдельные узлы в фрагменте XML, предоставляемые DOM Traversal (через класс NodeTest).

Различия между двумя частями XML (через классы Diff и DetailDiff).

Допустимость фрагмента XML (через класс Validator).

Результат преобразования фрагмента XML с использованием XSLT (через класс Transform).

Оценка выражения XPath на фрагменте XML (через классы, реализующие интерфейс XpathEngine).

Отдельные узлы в фрагменте XML, предоставляемые DOM Traversal (через класс NodeTest).

Допустим, у нас есть два фрагмента XML, которые мы хотим сравнить, и утверждаем, что они равны. Мы могли бы написать простой тестовый класс, как этот —

import org.custommonkey.xmlunit.XMLTestCase;

public class MyXMLTestCase extends XMLTestCase {

   // this test method compare two pieces of the XML
   @Test
   public void testForXMLEquality() throws Exception {
      String myControlXML = "<msg><uuid>0x00435A8C</uuid></msg>";
      String myTestXML = "<msg><localId>2376</localId></msg>";
      assertXMLEqual("Comparing test xml to control xml", myControlXML, myTestXML);
   }
}
MockObject
В модульном тесте фиктивные объекты могут имитировать поведение сложных, реальных (не фиктивных) объектов и поэтому полезны, когда реальный объект нецелесообразно или невозможно включить в модульный тест.

Общий стиль кодирования для тестирования с фиктивными объектами заключается в:

Создайте экземпляры фиктивных объектов.
Установите состояние и ожидания в макете объектов.
Вызвать код домена с фиктивными объектами в качестве параметров.
Проверьте согласованность в макете объектов.
Ниже приведен пример MockObject с использованием Jmock.